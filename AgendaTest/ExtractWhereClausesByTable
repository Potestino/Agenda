public Dictionary<string, List<string>> ExtractWhereClausesByTable(string soqlQuery)
{
    var result = new Dictionary<string, List<string>>();
    if (string.IsNullOrWhiteSpace(soqlQuery))
        return result;

    var decodedQuery = Uri.UnescapeDataString(soqlQuery.Replace("+", " "));
    
    // Match SELECT ... FROM tableName ... (until next SELECT or end)
    var selectBlocks = Regex.Matches(
        decodedQuery,
        @"SELECT\s+.*?\s+FROM\s+([a-zA-Z0-9_]+)\s+(.*?)(?=SELECT\s+|$)",
        RegexOptions.Singleline | RegexOptions.IgnoreCase);

    foreach (Match block in selectBlocks)
    {
        string tableName = block.Groups[1].Value.Trim();
        string blockContent = block.Groups[2].Value;

        int whereIndex = blockContent.IndexOf("WHERE", StringComparison.OrdinalIgnoreCase);
        if (whereIndex == -1)
            continue;

        string afterWhere = blockContent.Substring(whereIndex + 5).Trim();

        // Safely extract WHERE clause up to next keyword (outside parens)
        var buffer = new StringBuilder();
        int parenDepth = 0;
        bool inQuotes = false;

        for (int i = 0; i < afterWhere.Length; i++)
        {
            char c = afterWhere[i];

            if (c == '\'') inQuotes = !inQuotes;

            if (!inQuotes)
            {
                if (c == '(') parenDepth++;
                if (c == ')') parenDepth--;

                // Only break at keywords if not inside parens or quotes
                if (parenDepth == 0)
                {
                    string remainder = afterWhere.Substring(i).ToUpperInvariant();

                    if (remainder.StartsWith("ORDER BY") || remainder.StartsWith("GROUP BY") ||
                        remainder.StartsWith("HAVING") || remainder.StartsWith("LIMIT"))
                    {
                        break;
                    }
                }
            }

            buffer.Append(c);
        }

        string fullWhereClause = buffer.ToString().Trim();

        // Split conditions safely without cutting field names like "Owner_Country..."
        List<string> conditions = SplitConditionsSafely(fullWhereClause);

        // Optional: normalize terms
        var normalized = conditions.Select(c => c
            .Replace("= ''", "is empty value")
            .Replace("!= ''", "is not empty value")
            .Replace(">= ", "is on or after ")
            .Replace("<= ", "is on or before ")
            .Replace("> ", "is after ")
            .Replace("< ", "is before ")
            .Replace("= ", "is ")
            .Replace("!= ", "is not ")
            .Trim()).ToList();

        result[tableName] = normalized;
    }

    return result;
}
