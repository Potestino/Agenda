public Dictionary<string, List<string>> ExtractWhereClausesByTable(string soqlQuery)
{
    var result = new Dictionary<string, List<string>>();
    if (string.IsNullOrWhiteSpace(soqlQuery))
        return result;

    var decodedQuery = Uri.UnescapeDataString(soqlQuery.Replace("+", " "));
    var selectBlocks = Regex.Matches(decodedQuery, @"SELECT\s+.*?\s+FROM\s+([a-zA-Z0-9_]+)\s+(.*?)(?=SELECT\s+|$)", RegexOptions.Singleline | RegexOptions.IgnoreCase);

    foreach (Match block in selectBlocks)
    {
        var tableName = block.Groups[1].Value.Trim();
        var blockContent = block.Groups[2].Value;

        var whereIndex = blockContent.IndexOf("WHERE", StringComparison.OrdinalIgnoreCase);
        if (whereIndex == -1)
            continue;

        var afterWhere = blockContent.Substring(whereIndex + 5).Trim();

        var buffer = new StringBuilder();
        int parenDepth = 0;
        bool inQuotes = false;
        bool stop = false;

        for (int i = 0; i < afterWhere.Length && !stop; i++)
        {
            char c = afterWhere[i];

            if (c == '\'') inQuotes = !inQuotes;
            if (!inQuotes)
            {
                if (c == '(') parenDepth++;
                else if (c == ')') parenDepth--;

                // Only check for keyword if we're not inside parens or quotes
                if (parenDepth == 0)
                {
                    string remaining = afterWhere.Substring(i).ToUpperInvariant();

                    if (remaining.StartsWith("ORDER BY") || remaining.StartsWith("GROUP BY") ||
                        remaining.StartsWith("LIMIT") || remaining.StartsWith("HAVING"))
                    {
                        break;
                    }
                }
            }

            buffer.Append(c);
        }

        string filteredClause = buffer.ToString().Trim();

        // Tokenize conditions
        var conditions = new List<string>();
        var condBuffer = new StringBuilder();
        parenDepth = 0;
        inQuotes = false;

        for (int i = 0; i < filteredClause.Length; i++)
        {
            char c = filteredClause[i];
            if (c == '\'') inQuotes = !inQuotes;

            if (!inQuotes)
            {
                if (c == '(') parenDepth++;
                if (c == ')') parenDepth--;
            }

            if (!inQuotes && parenDepth == 0 && i + 4 <= filteredClause.Length)
            {
                string slice = filteredClause.Substring(i, 4).ToUpperInvariant();
                if (slice.StartsWith("AND ") || slice.StartsWith("OR "))
                {
                    conditions.Add(c
