public Dictionary<string, List<string>> ExtractWhereClausesByTable(string soqlQuery)
{
    var result = new Dictionary<string, List<string>>();
    if (string.IsNullOrWhiteSpace(soqlQuery))
        return result;

    var decodedQuery = Uri.UnescapeDataString(soqlQuery.Replace("+", " "));

    var selectBlocks = Regex.Matches(
        decodedQuery,
        @"SELECT\s+.*?\s+FROM\s+([a-zA-Z0-9_]+)\s+(.*?)(?=SELECT\s+|$)",
        RegexOptions.Singleline | RegexOptions.IgnoreCase);

    foreach (Match block in selectBlocks)
    {
        string tableName = block.Groups[1].Value.Trim();
        string blockContent = block.Groups[2].Value;

        int whereIndex = blockContent.IndexOf("WHERE", StringComparison.OrdinalIgnoreCase);
        if (whereIndex == -1)
            continue;

        string afterWhere = blockContent.Substring(whereIndex + 5).Trim();

        // Extract until ORDER BY / GROUP BY / HAVING / LIMIT outside parentheses
        var buffer = new StringBuilder();
        int parenDepth = 0;
        bool inQuotes = false;

        for (int i = 0; i < afterWhere.Length; i++)
        {
            char c = afterWhere[i];

            if (c == '\'') inQuotes = !inQuotes;
            if (!inQuotes)
            {
                if (c == '(') parenDepth++;
                if (c == ')') parenDepth--;
            }

            if (!inQuotes && parenDepth == 0)
            {
                string remainder = afterWhere.Substring(i);

                if (Regex.IsMatch(remainder, @"^(ORDER\s+BY|GROUP\s+BY|HAVING|LIMIT)\b", RegexOptions.IgnoreCase))
                    break;
            }

            buffer.Append(c);
        }

        string fullWhereClause = buffer.ToString().Trim();

        // Use Regex to split at true AND/OR boundaries
        var conditions = SplitConditionsPreservingFieldNames(fullWhereClause);

        // Normalize (optional)
        var normalized = conditions.Select(c => c
            .Replace("= ''", "is empty value")
            .Replace("!= ''", "is not empty value")
            .Replace(">= ", "is on or after ")
            .Replace("<= ", "is on or before ")
            .Replace("> ", "is after ")
            .Replace("< ", "is before ")
            .Replace("= ", "is ")
            .Replace("!= ", "is not ")
            .Trim()).ToList();

        result[tableName] = normalized;
    }

    return result;
}


private List<string> SplitConditionsPreservingFieldNames(string clause)
{
    var conditions = new List<string>();
    var buffer = new StringBuilder();
    int parenDepth = 0;
    bool inQuotes = false;

    for (int i = 0; i < clause.Length;)
    {
        // Detect quotes and parentheses
        char c = clause[i];
        if (c == '\'')
        {
            inQuotes = !inQuotes;
            buffer.Append(c);
            i++;
            continue;
        }

        if (!inQuotes)
        {
            if (c == '(') parenDepth++;
            else if (c == ')') parenDepth--;

            // Check for AND/OR with word boundaries
            if (parenDepth == 0 && i + 4 <= clause.Length)
            {
                var rest = clause.Substring(i);
                var match = Regex.Match(rest, @"^(AND|OR)\b", RegexOptions.IgnoreCase);
                if (match.Success)
                {
                    // Save condition before AND/OR
                    if (buffer.Length > 0)
                    {
                        conditions.Add(buffer.ToString().Trim());
                        buffer.Clear();
                    }

                    i += match.Length;
                    continue;
                }
            }
        }

        buffer.Append(c);
        i++;
    }

    if (buffer.Length > 0)
        conditions.Add(buffer.ToString().Trim());

    return conditions;
}
