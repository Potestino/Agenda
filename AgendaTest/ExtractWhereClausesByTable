public Dictionary<string, List<string>> ExtractWhereClausesByTable(string soqlQuery)
{
    var result = new Dictionary<string, List<string>>();
    if (string.IsNullOrWhiteSpace(soqlQuery))
        return result;

    var decodedQuery = Uri.UnescapeDataString(soqlQuery.Replace("+", " "));
    var selectBlocks = Regex.Matches(decodedQuery, @"SELECT\s+.*?\s+FROM\s+([a-zA-Z0-9_]+)\s+(.*?)(?=SELECT\s+|$)", RegexOptions.Singleline | RegexOptions.IgnoreCase);

    foreach (Match block in selectBlocks)
    {
        var tableName = block.Groups[1].Value.Trim();
        var blockContent = block.Groups[2].Value;

        var whereIndex = blockContent.IndexOf("WHERE", StringComparison.OrdinalIgnoreCase);
        if (whereIndex == -1)
            continue;

        var whereClause = blockContent.Substring(whereIndex + 5).Trim(); // Remove "WHERE"

        var stopKeywords = new[] { "ORDER BY", "GROUP BY", "HAVING", "LIMIT" };
        int endIndex = whereClause.Length;
        foreach (var keyword in stopKeywords)
        {
            var idx = whereClause.IndexOf(keyword, StringComparison.OrdinalIgnoreCase);
            if (idx != -1 && idx < endIndex)
                endIndex = idx;
        }

        var filteredClause = whereClause.Substring(0, endIndex).Trim();

        // Token-based split
        var conditions = new List<string>();
        var buffer = new StringBuilder();
        int parenDepth = 0;
        bool inQuotes = false;

        for (int i = 0; i < filteredClause.Length; i++)
        {
            char c = filteredClause[i];

            if (c == '\'')
                inQuotes = !inQuotes;

            if (!inQuotes)
            {
                if (c == '(') parenDepth++;
                if (c == ')') parenDepth--;
            }

            if (!inQuotes && parenDepth == 0 && i + 4 <= filteredClause.Length)
            {
                var substr = filteredClause.Substring(i, 4).ToUpperInvariant();
                if (substr.StartsWith("AND ") || substr.StartsWith("OR "))
                {
                    conditions.Add(buffer.ToString().Trim());
                    buffer.Clear();
                    i += 3; // Skip "AND " or "OR "
                    continue;
                }
            }

            buffer.Append(c);
        }

        if (buffer.Length > 0)
            conditions.Add(buffer.ToString().Trim());

        // Optional normalization
        var normalizedConditions = conditions.Select(c => c
            .Replace("= ''", "is empty value")
            .Replace("!= ''", "is not empty value")
            .Replace(">= ", "is on or after ")
            .Replace("<= ", "is on or before ")
            .Replace("> ", "is after ")
            .Replace("< ", "is before ")
            .Replace("= ", "is ")
            .Replace("!= ", "is not ")
            .Trim()).ToList();

        result[tableName] = normalizedConditions;
    }

    return result;
}
